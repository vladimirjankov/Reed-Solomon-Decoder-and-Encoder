//-----------------------------------------------------------
// @author: Vladimir Jankov & Milan Bjelic
// @email: vladimir.jankov@outlook.com & bjeliclaki@gmail.com
// @date: 27.8.2020
//-----------------------------------------------------------

#include <utility/fourier1023.h>

void fourier1023(Polynome poly, vector<Element> &output_fourier){

	vector<vector<Element>> b_i1_i2;
	b_i1_i2 = generate_crt_mapping_1023(poly);
	vector<vector<Element>> transform_matrix;
	transform_matrix = good_thomas_1023(b_i1_i2);
	output_fourier = rcn_mapping_1023(transform_matrix);
}

vector<vector<Element>> generate_crt_mapping_1023(Polynome poly){
	/* Generates CRT mapping matrix of size 11 x 3
	 * The corresponding index is calculated
	 * index = R_n(N1 * n1 * col + N2 * n2 * row)
	 * Calculation of n1 and n2 is done via Euclid algorithm
	 * N1 * n1 + N2 * n2 = 1
	 * @param input polynome to be transformed
	 * */

	int16_t n1, n2;
	euclid_gcd(N_FOURIER, N3, &n1, &n2);

	Polynome poly_reversed;
	poly_reversed = reverse_polynome(poly);
	vector<Element> reverted_poly_vec;
	reverted_poly_vec = poly_reversed.get_polynome();

	vector<vector<Element>> b_i1_i2(N_FOURIER, vector<Element>(N3,Element(0)));
	int16_t size = b_i1_i2.size();
	// Generate CRT mapping aka b_i1_i2
	for(uint16_t iterator1 = 0; iterator1 < N_FOURIER; ++iterator1){
		for(uint16_t iterator2 = 0; iterator2 < N3; ++iterator2){
			int16_t index = (N_FOURIER * n1 * iterator2 + N3 * n2 * iterator1) % N;
			if(index < 0)
				index = index + N;
			b_i1_i2[iterator1][iterator2] = reverted_poly_vec[index];
		}
	}

	return b_i1_i2;
}

vector<vector<Element>> good_thomas_1023(vector<vector<Element>> b_i1_i2){
	/* Performs Good Thomas algorithm and generates
	 * two-dimensional output B_{k1, k2} based on
	 * CRT mapping as input
	 * @param CRT mapping matrix of size N1 x N2
	 * @return B_{k1,k2} matrix size of N2 x N1
	 * */
	vector<vector<Element>> c_i1_k2(N_FOURIER, vector<Element>(N3, Element(0)));
	int16_t exponent = 1; // N_size / N -> 1
	Element omega(Element::table_of_exponents[exponent]);
	Element gama;
	gama = omega ^ N_FOURIER;
	for(uint16_t iterator1 = 0; iterator1 < N_FOURIER; ++iterator1){
		for(uint16_t iterator2 = 0; iterator2 < N3; ++iterator2){
			for(uint16_t iterator3 = 0; iterator3 < N3; ++iterator3){
				c_i1_k2[iterator1][iterator2] += ( (gama^(iterator2 * iterator3)) + b_i1_i2[iterator1][iterator3]);

			}
		}
	}

	Element beta;
	beta = omega ^ N3;
	vector<vector<Element>> output_matrix(N_FOURIER, vector<Element>(N3, Element(0)));

	// temporary vectors for calculating fft33
	vector<Element> fft33_input(N_FOURIER);
	vector<Element> fft33_output(N_FOURIER);

	for(uint16_t iterator1 = 0; iterator1 < N3 ; ++iterator1){
		// Give input sequence to vector input for fft
		for(uint16_t iterator2 = 0; iterator2 < N_FOURIER; ++iterator2){
			fft33_input[iterator2] = c_i1_k2[iterator2][iterator1];
		}
		Polynome fft_input(fft33_input);

		// Calculate fft33
		fourier33(fft_input, fft33_output);

		// Add fourier vector to output matrix
		for(uint16_t iterator2 = 0; iterator2 < N_FOURIER; ++iterator2){
			output_matrix[iterator2][iterator1] = fft33_output[iterator2];
		}
	}

	return output_matrix;
}

vector<Element> rcn_mapping_1023(vector<vector<Element>> transform_matrix){
	/* Returns one dimenzional vector of fourier based
	 * RCE mapping. Index are generated by following formula:
	 * k_1 = R_{N1}(N2 * k) k = 0,1,... N1-1
	 * k_2 = R_{N2}(N1 * k) k = 0,1,....N2-1
	 * and k = R_{N}(N2*k1 + N1 * k2)
	 * */
	vector<Element> output(N, Element(0));
	for(uint16_t iterator1 = 0; iterator1 < N_FOURIER; ++iterator1){
		for(uint16_t iterator2 = 0; iterator2 < N3 ; ++iterator2){
			int16_t index = (N3 * iterator1 + N_FOURIER * iterator2) % N;
			if(index < 0)
				index = index + N;
			output[index] = transform_matrix[iterator1][iterator2];
		}
	}
	return output;
}


