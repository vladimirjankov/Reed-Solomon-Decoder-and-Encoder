//-----------------------------------------------------------
// @author: Vladimir Jankov & Milan Bjelic
// @email: vladimir.jankov@outlook.com & bjeliclaki@gmail.com
// @date: 27.8.2020
//-----------------------------------------------------------
#include <utility/fourier33.h>

void fourier33(Polynome poly, vector<Element> &output_fourier){
	/* Performs fourier transform
	 * of size 33.
	 * @param input polynome with elemenst to transform
	 * @param output vector where to store elements of
	 * fourier transform.
	 * */
	vector<vector<Element>> b_i1_i2;
	b_i1_i2 = generate_crt_mapping(poly);
	vector<vector<Element>> transform_matrix;
	transform_matrix = good_thomas(b_i1_i2);
	output_fourier = rcn_mapping(transform_matrix);
}

vector<vector<Element>> generate_crt_mapping(Polynome poly){
	/* Generates CRT mapping matrix of size 11 x 3
	 * The corresponding index is calculated
	 * index = R_n(N1 * n1 * col + N2 * n2 * row)
	 * Calculation of n1 and n2 is done via Euclid algorithm
	 * N1 * n1 + N2 * n2 = 1
	 * @param input polynome to be transformed
	 * */

	int16_t n1, n2;
	euclid_gcd(N1, N2, &n1, &n2);
	vector<Element> poly_vector = poly.get_polynome();
	vector<vector<Element>> b_i1_i2(N1, vector<Element>(N2,Element(0)));
	// Generate CRT mapping aka b_i1_i2
	for(uint16_t iterator1 = 0 ; iterator1 < N1; ++iterator1){
		for(uint16_t iterator2 = 0; iterator2 < N2; ++iterator2){
			int16_t index = (N1 * n1 * iterator2 + N2 * n2 * iterator1) % N_FOURIER;
			if(index < 0)
				index = index + N_FOURIER;
			b_i1_i2[iterator1][iterator2] = poly_vector[index];
		}
	}

	return b_i1_i2;
}

vector<vector<Element>> good_thomas(vector<vector<Element>> b_i1_i2){
	/* Performs Good Thomas algorithm and generates
	 * two-dimensional output B_{k1, k2} based on
	 * CRT mapping as input
	 * @param CRT mapping matrix of size N1 x N2
	 * @return B_{k1,k2} matrix size of N2 x N1
	 * */
	vector<vector<Element>> c_i1_k2(N1, vector<Element>(N2,Element(0)));
	int16_t exponent = N / N_FOURIER;
	Element omega(Element::table_of_exponents[exponent]);
	Element gama;
	gama = omega ^ N1;

	for(uint16_t iterator1 = 0; iterator1 < N1; ++iterator1){
		for(uint16_t iterator2 = 0; iterator2 < N2; ++iterator2){
			for(uint16_t iterator3 = 0; iterator3 < N2; ++iterator3){
				c_i1_k2[iterator1][iterator2] += ( (gama^(iterator2 * iterator3)) + b_i1_i2[iterator1][iterator3]);
			}
		}
	}

	Element beta;
	beta = omega ^ N2;
	vector<vector<Element>> output_matrix(N2, vector<Element>(N1,Element(0)));
	for(uint16_t iterator1 = 0; iterator1 < N2; ++iterator1){
		for(uint16_t iterator2 = 0; iterator2 < N1; ++iterator2){
			for(uint16_t iterator3 = 0; iterator3 < N1; ++iterator3){
				output_matrix[iterator1][iterator2] += ((beta^(iterator2 * iterator3)) + c_i1_k2[iterator3][iterator1]);
			}
		}
	}

	return output_matrix;
}

vector<Element> rcn_mapping(vector<vector<Element>> transform_matrix){
	/* Returns one dimenzional vector of fourier based
	 * RCE mapping. Index are generated by following formula:
	 * k_1 = R_{N1}(N2 * k) k = 0,1,... N1-1
	 * k_2 = R_{N2}(N1 * k) k = 0,1,....N2-1
	 * and k = R_{N}(N2*k1 + N1 * k2)
	 * */
	vector<Element> output(N_FOURIER, Element(0));
	for(uint16_t iterator1 = 0; iterator1 < N2; ++iterator1){
		for(uint16_t iterator2 = 0; iterator2 < N1; ++iterator2){
			int16_t index = (N1 * iterator1 + N2 * iterator2) % N_FOURIER;
			if(index < 0)
				index = index + N_FOURIER;
			output[index] = transform_matrix[iterator1][iterator2];
		}
	}
	return output;
}


